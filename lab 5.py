# –ü–æ–ø–æ–≤ –Æ—Ä–∏–π –ò–£7-12–ë
# –ù–∞—Ö–æ–∂–¥–µ–Ω–∏–µ —Å—É–º–º—ã –º–∞—Ç —Ä—è–¥–∞ ùë¶ = 1 + ùë•/1 + (x ** 2) /2 + (x ** n) / n


# –í–≤–æ–¥
eps, step, n = map(float, input(
    '–í–≤–µ–¥–∏—Ç–µ —Ç–æ—á–Ω–æ—Å—Ç—å (float), —à–∞–≥ –ø–µ—á–∞—Ç—å (int) –∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏—Ç–µ—Ä–∞—Ü–∏–π (int) —á–µ—Ä–µ–∑ –ø—Ä–æ–±–µ–ª: ').split())
x = float(input('–í–≤–µ–¥–∏—Ç–µ x (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é x = 1): ') or 1)


def check_data(eps, step, n) -> tuple:
    '''–§—É—É–Ω–∫—Ü–∏—è –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –Ω–∞ –≤—Ö–æ–¥ –≤–≤–µ–¥–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∏ –≤–∞–ª–∏–¥–∏—Ä—É–µ—Ç –∏—Ö'''
    if step == int(step):
        step = int(step)
    else:
        raise Exception('Step must be integer')

    if n == int(n):
        n = int(n)
    else:
        raise Exception('number of iterations must be integer')

    return eps, step, n


eps, step, n = check_data(eps, step, n)

# –≤—ã—á–∏—Å–ª—è–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏
summ = 1  # –∏–∑–Ω–∞—á–∞–ª—å–Ω–∞ —Å—É–º–º–∞ —Ä–∞–≤–Ω–∞ –µ–¥–∏–Ω–∏—Ü–µ, —Ç–∫ –ø–µ—Ä–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç = 1
index = n
if n > 0:
    table = [(1, 1)]
else:
    table = []
for i in range(1, n):  # –ø–µ—Ä–≤–∞—è –∏—Ç—Ç–µ—Ä–∞—Ü–∏—è - –ø–µ—Ä–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç —Ä–∞–≤–µ–Ω 1 -> –æ—Å—Ç–∞–ª–æ—Å—å 9 –∏—Ç—Ç–µ—Ä–∞—Ü–∏–π
    cur = (x ** i) / i
    summ += cur
    if cur < eps:
        index = i
        break
    table.append((cur, summ))

# –ø–µ—Ä–µ–±–∏—Ä–∞–µ–º —Ç–∞–±–ª–∏—Ü—É –∏ –≤—ã–≤–æ–¥–∏–º
print('‚Äî' * 100)
print(f'‚îÉ{"‚Ññ –∏—Ç–µ—Ä–∞—Ü–∏–∏":^32}‚îÉ{"–¢–µ–∫—É—â–∏–π —ç–ª–µ–º–µ–Ω—Ç":^32}‚îÉ{"–°—É–º–º–∞ —Ä—è–¥–∞":^32}‚îÉ')
print('‚Äî' * 100)
for i in range(0, index, step):
    number = i
    cur = table[i][0]
    summ = table[i][1]
    print(f'‚îÉ{number + 1:^32.7g}‚îÉ{cur:^32.7g}‚îÉ{summ:^32.7g}‚îÉ')
print('‚Äî' * 100)
print(f'–°—É–º–º–∞ —Ä—è–¥–∞ —Ä–∞–≤–Ω–∞ - {table[index - 1][1]}. –ü–æ—Å—á–∏—Ç–∞–Ω–æ –∑–∞ {index} –∏—Ç–µ—Ä–∞—Ü–∏–π')


# cur = 4 * ((-1) ** i) / (2 * i + 1) —Ñ–æ—Ä–º—É–ª–∞ pi –Ω—É–∂–Ω–æ –º–Ω–æ–≥–æ –∏—Ç—Ç–µ—Ä–∞—Ü–∏–π